module Task3_3 where

{-
  Задание 3.3
  Множество на основе предикатов
-}

newtype PSet a = PSet{ contains :: (a -> Bool) }

-- Реализуйте классы Monoid и Functor
-- Объясните в комментариях, почему они реализованы именно так

-- Моноид в Haskell — это тип, 
-- для которого задано правило комбинирования двух элементов этого типа 
-- для получения нового элемента этого же типа.
-- Для реализации выбрана операция дизъюнкции, потому что он соответвует 
-- законам тождественности и ассоциотивности необходимых для реализации моноида.

-- Моноид должен соблюдать следующие законы (haskell к этому не принуждает,
-- но выполнения этих законов подразумеваются в любом моноиде) :
-- 1) mempty `mappend` x = x
-- 2) x `mappend` mempty = x
-- 3) (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)

-- В моноиде необходим "нейтральный элемент" комбинирование с которым 
-- любого другого элемента даёт результат, равный этому другому элементу.
-- mempty - нейтральный элемент, реализован следующим образом, 
-- тк добавление False к любой операции дизъюнкции не изменит результата. 
-- Так же необходима функция для комбинирования элементов,
-- это функция mapped, но c версии base-4.11.0.0. функция стала избыточна
-- поэтому будем использывать суперкласс Semigroup
instance Monoid (PSet a) where
 -- mempty :: PSet a
    mempty = PSet (\_ -> False)

-- (<>) - функция комбинирования нескольких элементов. 
-- (<>) :: PSet a -> PSet a -> PSet а
instance Semigroup (PSet a) where
    (<>) a b = PSet (\x -> contains a x || contains b x)

-- Функтор должен соответствовать двум законам:
-- 1) fmap id = id
-- 2) fmap (p . q) = (fmap p) . (fmap q)
 
-- функтор разворачивает значение из контекста -> применяет к нему функцию -> и вновь заворачивает значение в контекст.
-- но данный функтор не работает тк haskell не может применить функцию к аргументу типа PSet (ps инстанстно возращает Bool)
-- fmap :: (a -> b) -> f a -> f b
-- fmap должен быть в нашем случае:
-- fmap :: ((a -> Bool) -> (b -> Bool)) -> PSet (a -> Bool) -> PSet (b -> Bool)
instance Functor PSet where
    fmap f (PSet ps) = PSet (f ps)
